// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: github.com/heroiclabs/nakama-common/rtapi/realtime.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///*
/// The realtime protocol for Nakama server.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An envelope for a realtime message.
public struct Nakama_Realtime_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cid: String = String()

  public var message: Nakama_Realtime_Envelope.OneOf_Message? = nil

  /// A response from a channel join operation.
  public var channel: Nakama_Realtime_Channel {
    get {
      if case .channel(let v)? = message {return v}
      return Nakama_Realtime_Channel()
    }
    set {message = .channel(newValue)}
  }

  /// Join a realtime chat channel.
  public var channelJoin: Nakama_Realtime_ChannelJoin {
    get {
      if case .channelJoin(let v)? = message {return v}
      return Nakama_Realtime_ChannelJoin()
    }
    set {message = .channelJoin(newValue)}
  }

  /// Leave a realtime chat channel.
  public var channelLeave: Nakama_Realtime_ChannelLeave {
    get {
      if case .channelLeave(let v)? = message {return v}
      return Nakama_Realtime_ChannelLeave()
    }
    set {message = .channelLeave(newValue)}
  }

  /// An incoming message on a realtime chat channel.
  public var channelMessage: Nakama_Api_ChannelMessage {
    get {
      if case .channelMessage(let v)? = message {return v}
      return Nakama_Api_ChannelMessage()
    }
    set {message = .channelMessage(newValue)}
  }

  /// An acknowledgement received in response to sending a message on a chat channel.
  public var channelMessageAck: Nakama_Realtime_ChannelMessageAck {
    get {
      if case .channelMessageAck(let v)? = message {return v}
      return Nakama_Realtime_ChannelMessageAck()
    }
    set {message = .channelMessageAck(newValue)}
  }

  /// Send a message to a realtime chat channel.
  public var channelMessageSend: Nakama_Realtime_ChannelMessageSend {
    get {
      if case .channelMessageSend(let v)? = message {return v}
      return Nakama_Realtime_ChannelMessageSend()
    }
    set {message = .channelMessageSend(newValue)}
  }

  /// Update a message previously sent to a realtime chat channel.
  public var channelMessageUpdate: Nakama_Realtime_ChannelMessageUpdate {
    get {
      if case .channelMessageUpdate(let v)? = message {return v}
      return Nakama_Realtime_ChannelMessageUpdate()
    }
    set {message = .channelMessageUpdate(newValue)}
  }

  /// Remove a message previously sent to a realtime chat channel.
  public var channelMessageRemove: Nakama_Realtime_ChannelMessageRemove {
    get {
      if case .channelMessageRemove(let v)? = message {return v}
      return Nakama_Realtime_ChannelMessageRemove()
    }
    set {message = .channelMessageRemove(newValue)}
  }

  /// Presence update for a particular realtime chat channel.
  public var channelPresenceEvent: Nakama_Realtime_ChannelPresenceEvent {
    get {
      if case .channelPresenceEvent(let v)? = message {return v}
      return Nakama_Realtime_ChannelPresenceEvent()
    }
    set {message = .channelPresenceEvent(newValue)}
  }

  /// Describes an error which occurred on the server.
  public var error: Nakama_Realtime_Error {
    get {
      if case .error(let v)? = message {return v}
      return Nakama_Realtime_Error()
    }
    set {message = .error(newValue)}
  }

  /// Incoming information about a realtime match.
  public var match: Nakama_Realtime_Match {
    get {
      if case .match(let v)? = message {return v}
      return Nakama_Realtime_Match()
    }
    set {message = .match(newValue)}
  }

  /// A client to server request to create a realtime match.
  public var matchCreate: Nakama_Realtime_MatchCreate {
    get {
      if case .matchCreate(let v)? = message {return v}
      return Nakama_Realtime_MatchCreate()
    }
    set {message = .matchCreate(newValue)}
  }

  /// Incoming realtime match data delivered from the server.
  public var matchData: Nakama_Realtime_MatchData {
    get {
      if case .matchData(let v)? = message {return v}
      return Nakama_Realtime_MatchData()
    }
    set {message = .matchData(newValue)}
  }

  /// A client to server request to send data to a realtime match.
  public var matchDataSend: Nakama_Realtime_MatchDataSend {
    get {
      if case .matchDataSend(let v)? = message {return v}
      return Nakama_Realtime_MatchDataSend()
    }
    set {message = .matchDataSend(newValue)}
  }

  /// A client to server request to join a realtime match.
  public var matchJoin: Nakama_Realtime_MatchJoin {
    get {
      if case .matchJoin(let v)? = message {return v}
      return Nakama_Realtime_MatchJoin()
    }
    set {message = .matchJoin(newValue)}
  }

  /// A client to server request to leave a realtime match.
  public var matchLeave: Nakama_Realtime_MatchLeave {
    get {
      if case .matchLeave(let v)? = message {return v}
      return Nakama_Realtime_MatchLeave()
    }
    set {message = .matchLeave(newValue)}
  }

  /// Presence update for a particular realtime match.
  public var matchPresenceEvent: Nakama_Realtime_MatchPresenceEvent {
    get {
      if case .matchPresenceEvent(let v)? = message {return v}
      return Nakama_Realtime_MatchPresenceEvent()
    }
    set {message = .matchPresenceEvent(newValue)}
  }

  /// Submit a new matchmaking process request.
  public var matchmakerAdd: Nakama_Realtime_MatchmakerAdd {
    get {
      if case .matchmakerAdd(let v)? = message {return v}
      return Nakama_Realtime_MatchmakerAdd()
    }
    set {message = .matchmakerAdd(newValue)}
  }

  /// A successful matchmaking result.
  public var matchmakerMatched: Nakama_Realtime_MatchmakerMatched {
    get {
      if case .matchmakerMatched(let v)? = message {return v}
      return Nakama_Realtime_MatchmakerMatched()
    }
    set {message = .matchmakerMatched(newValue)}
  }

  /// Cancel a matchmaking process using a ticket.
  public var matchmakerRemove: Nakama_Realtime_MatchmakerRemove {
    get {
      if case .matchmakerRemove(let v)? = message {return v}
      return Nakama_Realtime_MatchmakerRemove()
    }
    set {message = .matchmakerRemove(newValue)}
  }

  /// A response from starting a new matchmaking process.
  public var matchmakerTicket: Nakama_Realtime_MatchmakerTicket {
    get {
      if case .matchmakerTicket(let v)? = message {return v}
      return Nakama_Realtime_MatchmakerTicket()
    }
    set {message = .matchmakerTicket(newValue)}
  }

  /// Notifications send by the server.
  public var notifications: Nakama_Realtime_Notifications {
    get {
      if case .notifications(let v)? = message {return v}
      return Nakama_Realtime_Notifications()
    }
    set {message = .notifications(newValue)}
  }

  /// RPC call or response.
  public var rpc: Nakama_Api_Rpc {
    get {
      if case .rpc(let v)? = message {return v}
      return Nakama_Api_Rpc()
    }
    set {message = .rpc(newValue)}
  }

  /// An incoming status snapshot for some set of users.
  public var status: Nakama_Realtime_Status {
    get {
      if case .status(let v)? = message {return v}
      return Nakama_Realtime_Status()
    }
    set {message = .status(newValue)}
  }

  /// Start following some set of users to receive their status updates.
  public var statusFollow: Nakama_Realtime_StatusFollow {
    get {
      if case .statusFollow(let v)? = message {return v}
      return Nakama_Realtime_StatusFollow()
    }
    set {message = .statusFollow(newValue)}
  }

  /// An incoming status update.
  public var statusPresenceEvent: Nakama_Realtime_StatusPresenceEvent {
    get {
      if case .statusPresenceEvent(let v)? = message {return v}
      return Nakama_Realtime_StatusPresenceEvent()
    }
    set {message = .statusPresenceEvent(newValue)}
  }

  /// Stop following some set of users to no longer receive their status updates.
  public var statusUnfollow: Nakama_Realtime_StatusUnfollow {
    get {
      if case .statusUnfollow(let v)? = message {return v}
      return Nakama_Realtime_StatusUnfollow()
    }
    set {message = .statusUnfollow(newValue)}
  }

  /// Set the user's own status.
  public var statusUpdate: Nakama_Realtime_StatusUpdate {
    get {
      if case .statusUpdate(let v)? = message {return v}
      return Nakama_Realtime_StatusUpdate()
    }
    set {message = .statusUpdate(newValue)}
  }

  /// A data message delivered over a stream.
  public var streamData: Nakama_Realtime_StreamData {
    get {
      if case .streamData(let v)? = message {return v}
      return Nakama_Realtime_StreamData()
    }
    set {message = .streamData(newValue)}
  }

  /// Presence update for a particular stream.
  public var streamPresenceEvent: Nakama_Realtime_StreamPresenceEvent {
    get {
      if case .streamPresenceEvent(let v)? = message {return v}
      return Nakama_Realtime_StreamPresenceEvent()
    }
    set {message = .streamPresenceEvent(newValue)}
  }

  /// Application-level heartbeat and connection check.
  public var ping: Nakama_Realtime_Ping {
    get {
      if case .ping(let v)? = message {return v}
      return Nakama_Realtime_Ping()
    }
    set {message = .ping(newValue)}
  }

  /// Application-level heartbeat and connection check response.
  public var pong: Nakama_Realtime_Pong {
    get {
      if case .pong(let v)? = message {return v}
      return Nakama_Realtime_Pong()
    }
    set {message = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    /// A response from a channel join operation.
    case channel(Nakama_Realtime_Channel)
    /// Join a realtime chat channel.
    case channelJoin(Nakama_Realtime_ChannelJoin)
    /// Leave a realtime chat channel.
    case channelLeave(Nakama_Realtime_ChannelLeave)
    /// An incoming message on a realtime chat channel.
    case channelMessage(Nakama_Api_ChannelMessage)
    /// An acknowledgement received in response to sending a message on a chat channel.
    case channelMessageAck(Nakama_Realtime_ChannelMessageAck)
    /// Send a message to a realtime chat channel.
    case channelMessageSend(Nakama_Realtime_ChannelMessageSend)
    /// Update a message previously sent to a realtime chat channel.
    case channelMessageUpdate(Nakama_Realtime_ChannelMessageUpdate)
    /// Remove a message previously sent to a realtime chat channel.
    case channelMessageRemove(Nakama_Realtime_ChannelMessageRemove)
    /// Presence update for a particular realtime chat channel.
    case channelPresenceEvent(Nakama_Realtime_ChannelPresenceEvent)
    /// Describes an error which occurred on the server.
    case error(Nakama_Realtime_Error)
    /// Incoming information about a realtime match.
    case match(Nakama_Realtime_Match)
    /// A client to server request to create a realtime match.
    case matchCreate(Nakama_Realtime_MatchCreate)
    /// Incoming realtime match data delivered from the server.
    case matchData(Nakama_Realtime_MatchData)
    /// A client to server request to send data to a realtime match.
    case matchDataSend(Nakama_Realtime_MatchDataSend)
    /// A client to server request to join a realtime match.
    case matchJoin(Nakama_Realtime_MatchJoin)
    /// A client to server request to leave a realtime match.
    case matchLeave(Nakama_Realtime_MatchLeave)
    /// Presence update for a particular realtime match.
    case matchPresenceEvent(Nakama_Realtime_MatchPresenceEvent)
    /// Submit a new matchmaking process request.
    case matchmakerAdd(Nakama_Realtime_MatchmakerAdd)
    /// A successful matchmaking result.
    case matchmakerMatched(Nakama_Realtime_MatchmakerMatched)
    /// Cancel a matchmaking process using a ticket.
    case matchmakerRemove(Nakama_Realtime_MatchmakerRemove)
    /// A response from starting a new matchmaking process.
    case matchmakerTicket(Nakama_Realtime_MatchmakerTicket)
    /// Notifications send by the server.
    case notifications(Nakama_Realtime_Notifications)
    /// RPC call or response.
    case rpc(Nakama_Api_Rpc)
    /// An incoming status snapshot for some set of users.
    case status(Nakama_Realtime_Status)
    /// Start following some set of users to receive their status updates.
    case statusFollow(Nakama_Realtime_StatusFollow)
    /// An incoming status update.
    case statusPresenceEvent(Nakama_Realtime_StatusPresenceEvent)
    /// Stop following some set of users to no longer receive their status updates.
    case statusUnfollow(Nakama_Realtime_StatusUnfollow)
    /// Set the user's own status.
    case statusUpdate(Nakama_Realtime_StatusUpdate)
    /// A data message delivered over a stream.
    case streamData(Nakama_Realtime_StreamData)
    /// Presence update for a particular stream.
    case streamPresenceEvent(Nakama_Realtime_StreamPresenceEvent)
    /// Application-level heartbeat and connection check.
    case ping(Nakama_Realtime_Ping)
    /// Application-level heartbeat and connection check response.
    case pong(Nakama_Realtime_Pong)

  #if !swift(>=4.1)
    public static func ==(lhs: Nakama_Realtime_Envelope.OneOf_Message, rhs: Nakama_Realtime_Envelope.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.channel, .channel): return {
        guard case .channel(let l) = lhs, case .channel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelJoin, .channelJoin): return {
        guard case .channelJoin(let l) = lhs, case .channelJoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelLeave, .channelLeave): return {
        guard case .channelLeave(let l) = lhs, case .channelLeave(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelMessage, .channelMessage): return {
        guard case .channelMessage(let l) = lhs, case .channelMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelMessageAck, .channelMessageAck): return {
        guard case .channelMessageAck(let l) = lhs, case .channelMessageAck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelMessageSend, .channelMessageSend): return {
        guard case .channelMessageSend(let l) = lhs, case .channelMessageSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelMessageUpdate, .channelMessageUpdate): return {
        guard case .channelMessageUpdate(let l) = lhs, case .channelMessageUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelMessageRemove, .channelMessageRemove): return {
        guard case .channelMessageRemove(let l) = lhs, case .channelMessageRemove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelPresenceEvent, .channelPresenceEvent): return {
        guard case .channelPresenceEvent(let l) = lhs, case .channelPresenceEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.match, .match): return {
        guard case .match(let l) = lhs, case .match(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchCreate, .matchCreate): return {
        guard case .matchCreate(let l) = lhs, case .matchCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchData, .matchData): return {
        guard case .matchData(let l) = lhs, case .matchData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchDataSend, .matchDataSend): return {
        guard case .matchDataSend(let l) = lhs, case .matchDataSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchJoin, .matchJoin): return {
        guard case .matchJoin(let l) = lhs, case .matchJoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchLeave, .matchLeave): return {
        guard case .matchLeave(let l) = lhs, case .matchLeave(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchPresenceEvent, .matchPresenceEvent): return {
        guard case .matchPresenceEvent(let l) = lhs, case .matchPresenceEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchmakerAdd, .matchmakerAdd): return {
        guard case .matchmakerAdd(let l) = lhs, case .matchmakerAdd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchmakerMatched, .matchmakerMatched): return {
        guard case .matchmakerMatched(let l) = lhs, case .matchmakerMatched(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchmakerRemove, .matchmakerRemove): return {
        guard case .matchmakerRemove(let l) = lhs, case .matchmakerRemove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.matchmakerTicket, .matchmakerTicket): return {
        guard case .matchmakerTicket(let l) = lhs, case .matchmakerTicket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notifications, .notifications): return {
        guard case .notifications(let l) = lhs, case .notifications(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rpc, .rpc): return {
        guard case .rpc(let l) = lhs, case .rpc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.status, .status): return {
        guard case .status(let l) = lhs, case .status(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusFollow, .statusFollow): return {
        guard case .statusFollow(let l) = lhs, case .statusFollow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusPresenceEvent, .statusPresenceEvent): return {
        guard case .statusPresenceEvent(let l) = lhs, case .statusPresenceEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusUnfollow, .statusUnfollow): return {
        guard case .statusUnfollow(let l) = lhs, case .statusUnfollow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusUpdate, .statusUpdate): return {
        guard case .statusUpdate(let l) = lhs, case .statusUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.streamData, .streamData): return {
        guard case .streamData(let l) = lhs, case .streamData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.streamPresenceEvent, .streamPresenceEvent): return {
        guard case .streamPresenceEvent(let l) = lhs, case .streamPresenceEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A realtime chat channel.
public struct Nakama_Realtime_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the channel.
  public var id: String = String()

  /// The users currently in the channel.
  public var presences: [Nakama_Realtime_UserPresence] = []

  /// A reference to the current user's presence in the channel.
  public var self_p: Nakama_Realtime_UserPresence {
    get {return _self_p ?? Nakama_Realtime_UserPresence()}
    set {_self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  public var hasSelf_p: Bool {return self._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  public mutating func clearSelf_p() {self._self_p = nil}

  /// The name of the chat room, or an empty string if this message was not sent through a chat room.
  public var roomName: String = String()

  /// The ID of the group, or an empty string if this message was not sent through a group channel.
  public var groupID: String = String()

  /// The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDOne: String = String()

  /// The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDTwo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _self_p: Nakama_Realtime_UserPresence? = nil
}

/// Join operation for a realtime chat channel.
public struct Nakama_Realtime_ChannelJoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user ID to DM with, group ID to chat with, or room channel name to join.
  public var target: String = String()

  /// The type of the chat channel.
  public var type: Int32 = 0

  /// Whether messages sent on this channel should be persistent.
  public var persistence: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _persistence ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_persistence = newValue}
  }
  /// Returns true if `persistence` has been explicitly set.
  public var hasPersistence: Bool {return self._persistence != nil}
  /// Clears the value of `persistence`. Subsequent reads from it will return its default value.
  public mutating func clearPersistence() {self._persistence = nil}

  /// Whether the user should appear in the channel's presence list and events.
  public var hidden: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _hidden ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  public var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  public mutating func clearHidden() {self._hidden = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of chat channel.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default case. Assumed as ROOM type.
    case unspecified // = 0

    /// A room which anyone can join to chat.
    case room // = 1

    /// A private channel for 1-on-1 chat.
    case directMessage // = 2

    /// A channel for group chat.
    case group // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .room
      case 2: self = .directMessage
      case 3: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .room: return 1
      case .directMessage: return 2
      case .group: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _persistence: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _hidden: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

#if swift(>=4.2)

extension Nakama_Realtime_ChannelJoin.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Nakama_Realtime_ChannelJoin.TypeEnum] = [
    .unspecified,
    .room,
    .directMessage,
    .group,
  ]
}

#endif  // swift(>=4.2)

/// Leave a realtime channel.
public struct Nakama_Realtime_ChannelLeave {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the channel to leave.
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A receipt reply from a channel message send operation.
public struct Nakama_Realtime_ChannelMessageAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel the message was sent to.
  public var channelID: String = String()

  /// The unique ID assigned to the message.
  public var messageID: String = String()

  /// The code representing a message type or category.
  public var code: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _code ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  public var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  public mutating func clearCode() {self._code = nil}

  /// Username of the message sender.
  public var username: String = String()

  /// The UNIX time when the message was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// The UNIX time when the message was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// True if the message was persisted to the channel's history, false otherwise.
  public var persistent: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _persistent ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_persistent = newValue}
  }
  /// Returns true if `persistent` has been explicitly set.
  public var hasPersistent: Bool {return self._persistent != nil}
  /// Clears the value of `persistent`. Subsequent reads from it will return its default value.
  public mutating func clearPersistent() {self._persistent = nil}

  /// The name of the chat room, or an empty string if this message was not sent through a chat room.
  public var roomName: String = String()

  /// The ID of the group, or an empty string if this message was not sent through a group channel.
  public var groupID: String = String()

  /// The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDOne: String = String()

  /// The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDTwo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _code: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _persistent: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Send a message to a realtime channel.
public struct Nakama_Realtime_ChannelMessageSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel to sent to.
  public var channelID: String = String()

  /// Message content.
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update a message previously sent to a realtime channel.
public struct Nakama_Realtime_ChannelMessageUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel the message was sent to.
  public var channelID: String = String()

  /// The ID assigned to the message to update.
  public var messageID: String = String()

  /// New message content.
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Remove a message previously sent to a realtime channel.
public struct Nakama_Realtime_ChannelMessageRemove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel the message was sent to.
  public var channelID: String = String()

  /// The ID assigned to the message to update.
  public var messageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A set of joins and leaves on a particular channel.
public struct Nakama_Realtime_ChannelPresenceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel identifier this event is for.
  public var channelID: String = String()

  /// Presences joining the channel as part of this event, if any.
  public var joins: [Nakama_Realtime_UserPresence] = []

  /// Presences leaving the channel as part of this event, if any.
  public var leaves: [Nakama_Realtime_UserPresence] = []

  /// The name of the chat room, or an empty string if this message was not sent through a chat room.
  public var roomName: String = String()

  /// The ID of the group, or an empty string if this message was not sent through a group channel.
  public var groupID: String = String()

  /// The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDOne: String = String()

  /// The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDTwo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A logical error which may occur on the server.
public struct Nakama_Realtime_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The error code which should be one of "Error.Code" enums.
  public var code: Int32 = 0

  /// A message in English to help developers debug the response.
  public var message: String = String()

  /// Additional error details which may be different for each response.
  public var context: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The selection of possible error codes.
  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unexpected result from the server.
    case runtimeException // = 0

    /// The server received a message which is not recognised.
    case unrecognizedPayload // = 1

    /// A message was expected but contains no content.
    case missingPayload // = 2

    /// Fields in the message have an invalid format.
    case badInput // = 3

    /// The match id was not found.
    case matchNotFound // = 4

    /// The match join was rejected.
    case matchJoinRejected // = 5

    /// The runtime function does not exist on the server.
    case runtimeFunctionNotFound // = 6

    /// The runtime function executed with an error.
    case runtimeFunctionException // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .runtimeException
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .runtimeException
      case 1: self = .unrecognizedPayload
      case 2: self = .missingPayload
      case 3: self = .badInput
      case 4: self = .matchNotFound
      case 5: self = .matchJoinRejected
      case 6: self = .runtimeFunctionNotFound
      case 7: self = .runtimeFunctionException
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .runtimeException: return 0
      case .unrecognizedPayload: return 1
      case .missingPayload: return 2
      case .badInput: return 3
      case .matchNotFound: return 4
      case .matchJoinRejected: return 5
      case .runtimeFunctionNotFound: return 6
      case .runtimeFunctionException: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Nakama_Realtime_Error.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Nakama_Realtime_Error.Code] = [
    .runtimeException,
    .unrecognizedPayload,
    .missingPayload,
    .badInput,
    .matchNotFound,
    .matchJoinRejected,
    .runtimeFunctionNotFound,
    .runtimeFunctionException,
  ]
}

#endif  // swift(>=4.2)

/// A realtime match.
public struct Nakama_Realtime_Match {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The match unique ID.
  public var matchID: String = String()

  /// True if it's an server-managed authoritative match, false otherwise.
  public var authoritative: Bool = false

  /// Match label, if any.
  public var label: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _label ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  public var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  public mutating func clearLabel() {self._label = nil}

  /// The number of users currently in the match.
  public var size: Int32 = 0

  /// The users currently in the match.
  public var presences: [Nakama_Realtime_UserPresence] = []

  /// A reference to the current user's presence in the match.
  public var self_p: Nakama_Realtime_UserPresence {
    get {return _self_p ?? Nakama_Realtime_UserPresence()}
    set {_self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  public var hasSelf_p: Bool {return self._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  public mutating func clearSelf_p() {self._self_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _label: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _self_p: Nakama_Realtime_UserPresence? = nil
}

/// Create a new realtime match.
public struct Nakama_Realtime_MatchCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Realtime match data received from the server.
public struct Nakama_Realtime_MatchData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The match unique ID.
  public var matchID: String = String()

  /// A reference to the user presence that sent this data, if any.
  public var presence: Nakama_Realtime_UserPresence {
    get {return _presence ?? Nakama_Realtime_UserPresence()}
    set {_presence = newValue}
  }
  /// Returns true if `presence` has been explicitly set.
  public var hasPresence: Bool {return self._presence != nil}
  /// Clears the value of `presence`. Subsequent reads from it will return its default value.
  public mutating func clearPresence() {self._presence = nil}

  /// Op code value.
  public var opCode: Int64 = 0

  /// Data payload, if any.
  public var data: Data = Data()

  /// True if this data was delivered reliably, false otherwise.
  public var reliable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _presence: Nakama_Realtime_UserPresence? = nil
}

/// Send realtime match data to the server.
public struct Nakama_Realtime_MatchDataSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The match unique ID.
  public var matchID: String = String()

  /// Op code value.
  public var opCode: Int64 = 0

  /// Data payload, if any.
  public var data: Data = Data()

  /// List of presences in the match to deliver to, if filtering is required. Otherwise deliver to everyone in the match.
  public var presences: [Nakama_Realtime_UserPresence] = []

  /// True if the data should be sent reliably, false otherwise.
  public var reliable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Join an existing realtime match.
public struct Nakama_Realtime_MatchJoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Nakama_Realtime_MatchJoin.OneOf_ID? = nil

  /// The match unique ID.
  public var matchID: String {
    get {
      if case .matchID(let v)? = id {return v}
      return String()
    }
    set {id = .matchID(newValue)}
  }

  /// A matchmaking result token.
  public var token: String {
    get {
      if case .token(let v)? = id {return v}
      return String()
    }
    set {id = .token(newValue)}
  }

  /// An optional set of key-value metadata pairs to be passed to the match handler, if any.
  public var metadata: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ID: Equatable {
    /// The match unique ID.
    case matchID(String)
    /// A matchmaking result token.
    case token(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Nakama_Realtime_MatchJoin.OneOf_ID, rhs: Nakama_Realtime_MatchJoin.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.matchID, .matchID): return {
        guard case .matchID(let l) = lhs, case .matchID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.token, .token): return {
        guard case .token(let l) = lhs, case .token(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Leave a realtime match.
public struct Nakama_Realtime_MatchLeave {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The match unique ID.
  public var matchID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A set of joins and leaves on a particular realtime match.
public struct Nakama_Realtime_MatchPresenceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The match unique ID.
  public var matchID: String = String()

  /// User presences that have just joined the match.
  public var joins: [Nakama_Realtime_UserPresence] = []

  /// User presences that have just left the match.
  public var leaves: [Nakama_Realtime_UserPresence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Start a new matchmaking process.
public struct Nakama_Realtime_MatchmakerAdd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum total user count to match together.
  public var minCount: Int32 = 0

  /// Maximum total user count to match together.
  public var maxCount: Int32 = 0

  /// Filter query used to identify suitable users.
  public var query: String = String()

  /// String properties.
  public var stringProperties: Dictionary<String,String> = [:]

  /// Numeric properties.
  public var numericProperties: Dictionary<String,Double> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A successful matchmaking result.
public struct Nakama_Realtime_MatchmakerMatched {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The matchmaking ticket that has completed.
  public var ticket: String = String()

  /// The match token or match ID to join.
  public var id: Nakama_Realtime_MatchmakerMatched.OneOf_ID? = nil

  /// Match ID.
  public var matchID: String {
    get {
      if case .matchID(let v)? = id {return v}
      return String()
    }
    set {id = .matchID(newValue)}
  }

  /// Match join token.
  public var token: String {
    get {
      if case .token(let v)? = id {return v}
      return String()
    }
    set {id = .token(newValue)}
  }

  /// The users that have been matched together, and information about their matchmaking data.
  public var users: [Nakama_Realtime_MatchmakerMatched.MatchmakerUser] = []

  /// A reference to the current user and their properties.
  public var self_p: Nakama_Realtime_MatchmakerMatched.MatchmakerUser {
    get {return _self_p ?? Nakama_Realtime_MatchmakerMatched.MatchmakerUser()}
    set {_self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  public var hasSelf_p: Bool {return self._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  public mutating func clearSelf_p() {self._self_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The match token or match ID to join.
  public enum OneOf_ID: Equatable {
    /// Match ID.
    case matchID(String)
    /// Match join token.
    case token(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Nakama_Realtime_MatchmakerMatched.OneOf_ID, rhs: Nakama_Realtime_MatchmakerMatched.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.matchID, .matchID): return {
        guard case .matchID(let l) = lhs, case .matchID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.token, .token): return {
        guard case .token(let l) = lhs, case .token(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct MatchmakerUser {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User info.
    public var presence: Nakama_Realtime_UserPresence {
      get {return _presence ?? Nakama_Realtime_UserPresence()}
      set {_presence = newValue}
    }
    /// Returns true if `presence` has been explicitly set.
    public var hasPresence: Bool {return self._presence != nil}
    /// Clears the value of `presence`. Subsequent reads from it will return its default value.
    public mutating func clearPresence() {self._presence = nil}

    /// String properties.
    public var stringProperties: Dictionary<String,String> = [:]

    /// Numeric properties.
    public var numericProperties: Dictionary<String,Double> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _presence: Nakama_Realtime_UserPresence? = nil
  }

  public init() {}

  fileprivate var _self_p: Nakama_Realtime_MatchmakerMatched.MatchmakerUser? = nil
}

/// Cancel an existing ongoing matchmaking process.
public struct Nakama_Realtime_MatchmakerRemove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ticket to cancel.
  public var ticket: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A ticket representing a new matchmaking process.
public struct Nakama_Realtime_MatchmakerTicket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ticket that can be used to cancel matchmaking.
  public var ticket: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of zero or more notifications.
public struct Nakama_Realtime_Notifications {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collection of notifications.
  public var notifications: [Nakama_Api_Notification] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Application-level heartbeat and connection check.
public struct Nakama_Realtime_Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Application-level heartbeat and connection check response.
public struct Nakama_Realtime_Pong {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A snapshot of statuses for some set of users.
public struct Nakama_Realtime_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User statuses.
  public var presences: [Nakama_Realtime_UserPresence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Start receiving status updates for some set of users.
public struct Nakama_Realtime_StatusFollow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User IDs to follow.
  public var userIds: [String] = []

  /// Usernames to follow.
  public var usernames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A batch of status updates for a given user.
public struct Nakama_Realtime_StatusPresenceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// New statuses for the user.
  public var joins: [Nakama_Realtime_UserPresence] = []

  /// Previous statuses for the user.
  public var leaves: [Nakama_Realtime_UserPresence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Stop receiving status updates for some set of users.
public struct Nakama_Realtime_StatusUnfollow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Users to unfollow.
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Set the user's own status.
public struct Nakama_Realtime_StatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status string to set, if not present the user will appear offline.
  public var status: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _status ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// Represents identifying information for a stream.
public struct Nakama_Realtime_Stream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mode identifies the type of stream.
  public var mode: Int32 = 0

  /// Subject is the primary identifier, if any.
  public var subject: String = String()

  /// Subcontext is a secondary identifier, if any.
  public var subcontext: String = String()

  /// The label is an arbitrary identifying string, if the stream has one.
  public var label: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A data message delivered over a stream.
public struct Nakama_Realtime_StreamData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The stream this data message relates to.
  public var stream: Nakama_Realtime_Stream {
    get {return _stream ?? Nakama_Realtime_Stream()}
    set {_stream = newValue}
  }
  /// Returns true if `stream` has been explicitly set.
  public var hasStream: Bool {return self._stream != nil}
  /// Clears the value of `stream`. Subsequent reads from it will return its default value.
  public mutating func clearStream() {self._stream = nil}

  /// The sender, if any.
  public var sender: Nakama_Realtime_UserPresence {
    get {return _sender ?? Nakama_Realtime_UserPresence()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  /// Arbitrary contents of the data message.
  public var data: String = String()

  /// True if this data was delivered reliably, false otherwise.
  public var reliable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stream: Nakama_Realtime_Stream? = nil
  fileprivate var _sender: Nakama_Realtime_UserPresence? = nil
}

/// A set of joins and leaves on a particular stream.
public struct Nakama_Realtime_StreamPresenceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The stream this event relates to.
  public var stream: Nakama_Realtime_Stream {
    get {return _stream ?? Nakama_Realtime_Stream()}
    set {_stream = newValue}
  }
  /// Returns true if `stream` has been explicitly set.
  public var hasStream: Bool {return self._stream != nil}
  /// Clears the value of `stream`. Subsequent reads from it will return its default value.
  public mutating func clearStream() {self._stream = nil}

  /// Presences joining the stream as part of this event, if any.
  public var joins: [Nakama_Realtime_UserPresence] = []

  /// Presences leaving the stream as part of this event, if any.
  public var leaves: [Nakama_Realtime_UserPresence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stream: Nakama_Realtime_Stream? = nil
}

/// A user session associated to a stream, usually through a list operation or a join/leave event.
public struct Nakama_Realtime_UserPresence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user this presence belongs to.
  public var userID: String = String()

  /// A unique session ID identifying the particular connection, because the user may have many.
  public var sessionID: String = String()

  /// The username for display purposes.
  public var username: String = String()

  /// Whether this presence generates persistent data/messages, if applicable for the stream type.
  public var persistence: Bool = false

  /// A user-set status message for this stream, if applicable.
  public var status: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _status ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nakama.realtime"

extension Nakama_Realtime_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cid"),
    2: .same(proto: "channel"),
    3: .standard(proto: "channel_join"),
    4: .standard(proto: "channel_leave"),
    5: .standard(proto: "channel_message"),
    6: .standard(proto: "channel_message_ack"),
    7: .standard(proto: "channel_message_send"),
    8: .standard(proto: "channel_message_update"),
    9: .standard(proto: "channel_message_remove"),
    10: .standard(proto: "channel_presence_event"),
    11: .same(proto: "error"),
    12: .same(proto: "match"),
    13: .standard(proto: "match_create"),
    14: .standard(proto: "match_data"),
    15: .standard(proto: "match_data_send"),
    16: .standard(proto: "match_join"),
    17: .standard(proto: "match_leave"),
    18: .standard(proto: "match_presence_event"),
    19: .standard(proto: "matchmaker_add"),
    20: .standard(proto: "matchmaker_matched"),
    21: .standard(proto: "matchmaker_remove"),
    22: .standard(proto: "matchmaker_ticket"),
    23: .same(proto: "notifications"),
    24: .same(proto: "rpc"),
    25: .same(proto: "status"),
    26: .standard(proto: "status_follow"),
    27: .standard(proto: "status_presence_event"),
    28: .standard(proto: "status_unfollow"),
    29: .standard(proto: "status_update"),
    30: .standard(proto: "stream_data"),
    31: .standard(proto: "stream_presence_event"),
    32: .same(proto: "ping"),
    33: .same(proto: "pong"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cid) }()
      case 2: try {
        var v: Nakama_Realtime_Channel?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channel(v)}
      }()
      case 3: try {
        var v: Nakama_Realtime_ChannelJoin?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelJoin(v)}
      }()
      case 4: try {
        var v: Nakama_Realtime_ChannelLeave?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelLeave(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelLeave(v)}
      }()
      case 5: try {
        var v: Nakama_Api_ChannelMessage?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelMessage(v)}
      }()
      case 6: try {
        var v: Nakama_Realtime_ChannelMessageAck?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelMessageAck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelMessageAck(v)}
      }()
      case 7: try {
        var v: Nakama_Realtime_ChannelMessageSend?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelMessageSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelMessageSend(v)}
      }()
      case 8: try {
        var v: Nakama_Realtime_ChannelMessageUpdate?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelMessageUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelMessageUpdate(v)}
      }()
      case 9: try {
        var v: Nakama_Realtime_ChannelMessageRemove?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelMessageRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelMessageRemove(v)}
      }()
      case 10: try {
        var v: Nakama_Realtime_ChannelPresenceEvent?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .channelPresenceEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .channelPresenceEvent(v)}
      }()
      case 11: try {
        var v: Nakama_Realtime_Error?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .error(v)}
      }()
      case 12: try {
        var v: Nakama_Realtime_Match?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .match(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .match(v)}
      }()
      case 13: try {
        var v: Nakama_Realtime_MatchCreate?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchCreate(v)}
      }()
      case 14: try {
        var v: Nakama_Realtime_MatchData?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchData(v)}
      }()
      case 15: try {
        var v: Nakama_Realtime_MatchDataSend?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchDataSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchDataSend(v)}
      }()
      case 16: try {
        var v: Nakama_Realtime_MatchJoin?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchJoin(v)}
      }()
      case 17: try {
        var v: Nakama_Realtime_MatchLeave?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchLeave(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchLeave(v)}
      }()
      case 18: try {
        var v: Nakama_Realtime_MatchPresenceEvent?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchPresenceEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchPresenceEvent(v)}
      }()
      case 19: try {
        var v: Nakama_Realtime_MatchmakerAdd?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchmakerAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchmakerAdd(v)}
      }()
      case 20: try {
        var v: Nakama_Realtime_MatchmakerMatched?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchmakerMatched(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchmakerMatched(v)}
      }()
      case 21: try {
        var v: Nakama_Realtime_MatchmakerRemove?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchmakerRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchmakerRemove(v)}
      }()
      case 22: try {
        var v: Nakama_Realtime_MatchmakerTicket?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .matchmakerTicket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .matchmakerTicket(v)}
      }()
      case 23: try {
        var v: Nakama_Realtime_Notifications?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .notifications(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .notifications(v)}
      }()
      case 24: try {
        var v: Nakama_Api_Rpc?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .rpc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .rpc(v)}
      }()
      case 25: try {
        var v: Nakama_Realtime_Status?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .status(v)}
      }()
      case 26: try {
        var v: Nakama_Realtime_StatusFollow?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .statusFollow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .statusFollow(v)}
      }()
      case 27: try {
        var v: Nakama_Realtime_StatusPresenceEvent?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .statusPresenceEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .statusPresenceEvent(v)}
      }()
      case 28: try {
        var v: Nakama_Realtime_StatusUnfollow?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .statusUnfollow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .statusUnfollow(v)}
      }()
      case 29: try {
        var v: Nakama_Realtime_StatusUpdate?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .statusUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .statusUpdate(v)}
      }()
      case 30: try {
        var v: Nakama_Realtime_StreamData?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .streamData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .streamData(v)}
      }()
      case 31: try {
        var v: Nakama_Realtime_StreamPresenceEvent?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .streamPresenceEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .streamPresenceEvent(v)}
      }()
      case 32: try {
        var v: Nakama_Realtime_Ping?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .ping(v)}
      }()
      case 33: try {
        var v: Nakama_Realtime_Pong?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .pong(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cid.isEmpty {
      try visitor.visitSingularStringField(value: self.cid, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .channel?: try {
      guard case .channel(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .channelJoin?: try {
      guard case .channelJoin(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .channelLeave?: try {
      guard case .channelLeave(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .channelMessage?: try {
      guard case .channelMessage(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .channelMessageAck?: try {
      guard case .channelMessageAck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .channelMessageSend?: try {
      guard case .channelMessageSend(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .channelMessageUpdate?: try {
      guard case .channelMessageUpdate(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .channelMessageRemove?: try {
      guard case .channelMessageRemove(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .channelPresenceEvent?: try {
      guard case .channelPresenceEvent(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .error?: try {
      guard case .error(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .match?: try {
      guard case .match(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .matchCreate?: try {
      guard case .matchCreate(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .matchData?: try {
      guard case .matchData(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .matchDataSend?: try {
      guard case .matchDataSend(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .matchJoin?: try {
      guard case .matchJoin(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .matchLeave?: try {
      guard case .matchLeave(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .matchPresenceEvent?: try {
      guard case .matchPresenceEvent(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .matchmakerAdd?: try {
      guard case .matchmakerAdd(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .matchmakerMatched?: try {
      guard case .matchmakerMatched(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .matchmakerRemove?: try {
      guard case .matchmakerRemove(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .matchmakerTicket?: try {
      guard case .matchmakerTicket(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .notifications?: try {
      guard case .notifications(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .rpc?: try {
      guard case .rpc(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .status?: try {
      guard case .status(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .statusFollow?: try {
      guard case .statusFollow(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .statusPresenceEvent?: try {
      guard case .statusPresenceEvent(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .statusUnfollow?: try {
      guard case .statusUnfollow(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .statusUpdate?: try {
      guard case .statusUpdate(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .streamData?: try {
      guard case .streamData(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .streamPresenceEvent?: try {
      guard case .streamPresenceEvent(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Envelope, rhs: Nakama_Realtime_Envelope) -> Bool {
    if lhs.cid != rhs.cid {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Channel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "presences"),
    3: .same(proto: "self"),
    4: .standard(proto: "room_name"),
    5: .standard(proto: "group_id"),
    6: .standard(proto: "user_id_one"),
    7: .standard(proto: "user_id_two"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.presences) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._self_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.roomName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userIDOne) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.userIDTwo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.presences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.presences, fieldNumber: 2)
    }
    if let v = self._self_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.roomName.isEmpty {
      try visitor.visitSingularStringField(value: self.roomName, fieldNumber: 4)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 5)
    }
    if !self.userIDOne.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDOne, fieldNumber: 6)
    }
    if !self.userIDTwo.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDTwo, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Channel, rhs: Nakama_Realtime_Channel) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.presences != rhs.presences {return false}
    if lhs._self_p != rhs._self_p {return false}
    if lhs.roomName != rhs.roomName {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIDOne != rhs.userIDOne {return false}
    if lhs.userIDTwo != rhs.userIDTwo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_ChannelJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelJoin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "type"),
    3: .same(proto: "persistence"),
    4: .same(proto: "hidden"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._persistence) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._hidden) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    if let v = self._persistence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._hidden {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_ChannelJoin, rhs: Nakama_Realtime_ChannelJoin) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.type != rhs.type {return false}
    if lhs._persistence != rhs._persistence {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_ChannelJoin.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "ROOM"),
    2: .same(proto: "DIRECT_MESSAGE"),
    3: .same(proto: "GROUP"),
  ]
}

extension Nakama_Realtime_ChannelLeave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelLeave"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_ChannelLeave, rhs: Nakama_Realtime_ChannelLeave) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_ChannelMessageAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMessageAck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "code"),
    4: .same(proto: "username"),
    5: .standard(proto: "create_time"),
    6: .standard(proto: "update_time"),
    7: .same(proto: "persistent"),
    8: .standard(proto: "room_name"),
    9: .standard(proto: "group_id"),
    10: .standard(proto: "user_id_one"),
    11: .standard(proto: "user_id_two"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._code) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._persistent) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.roomName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.userIDOne) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.userIDTwo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    if let v = self._code {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 4)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._persistent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.roomName.isEmpty {
      try visitor.visitSingularStringField(value: self.roomName, fieldNumber: 8)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 9)
    }
    if !self.userIDOne.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDOne, fieldNumber: 10)
    }
    if !self.userIDTwo.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDTwo, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_ChannelMessageAck, rhs: Nakama_Realtime_ChannelMessageAck) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._code != rhs._code {return false}
    if lhs.username != rhs.username {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs._persistent != rhs._persistent {return false}
    if lhs.roomName != rhs.roomName {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIDOne != rhs.userIDOne {return false}
    if lhs.userIDTwo != rhs.userIDTwo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_ChannelMessageSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMessageSend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_ChannelMessageSend, rhs: Nakama_Realtime_ChannelMessageSend) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_ChannelMessageUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMessageUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_ChannelMessageUpdate, rhs: Nakama_Realtime_ChannelMessageUpdate) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_ChannelMessageRemove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMessageRemove"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_ChannelMessageRemove, rhs: Nakama_Realtime_ChannelMessageRemove) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_ChannelPresenceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelPresenceEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "joins"),
    3: .same(proto: "leaves"),
    4: .standard(proto: "room_name"),
    5: .standard(proto: "group_id"),
    6: .standard(proto: "user_id_one"),
    7: .standard(proto: "user_id_two"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.joins) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.leaves) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.roomName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userIDOne) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.userIDTwo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.joins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.joins, fieldNumber: 2)
    }
    if !self.leaves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaves, fieldNumber: 3)
    }
    if !self.roomName.isEmpty {
      try visitor.visitSingularStringField(value: self.roomName, fieldNumber: 4)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 5)
    }
    if !self.userIDOne.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDOne, fieldNumber: 6)
    }
    if !self.userIDTwo.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDTwo, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_ChannelPresenceEvent, rhs: Nakama_Realtime_ChannelPresenceEvent) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.joins != rhs.joins {return false}
    if lhs.leaves != rhs.leaves {return false}
    if lhs.roomName != rhs.roomName {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIDOne != rhs.userIDOne {return false}
    if lhs.userIDTwo != rhs.userIDTwo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.context.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.context, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Error, rhs: Nakama_Realtime_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Error.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNTIME_EXCEPTION"),
    1: .same(proto: "UNRECOGNIZED_PAYLOAD"),
    2: .same(proto: "MISSING_PAYLOAD"),
    3: .same(proto: "BAD_INPUT"),
    4: .same(proto: "MATCH_NOT_FOUND"),
    5: .same(proto: "MATCH_JOIN_REJECTED"),
    6: .same(proto: "RUNTIME_FUNCTION_NOT_FOUND"),
    7: .same(proto: "RUNTIME_FUNCTION_EXCEPTION"),
  ]
}

extension Nakama_Realtime_Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Match"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "authoritative"),
    3: .same(proto: "label"),
    4: .same(proto: "size"),
    5: .same(proto: "presences"),
    6: .same(proto: "self"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.matchID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.authoritative) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._label) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.presences) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._self_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    if self.authoritative != false {
      try visitor.visitSingularBoolField(value: self.authoritative, fieldNumber: 2)
    }
    if let v = self._label {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 4)
    }
    if !self.presences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.presences, fieldNumber: 5)
    }
    if let v = self._self_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Match, rhs: Nakama_Realtime_Match) -> Bool {
    if lhs.matchID != rhs.matchID {return false}
    if lhs.authoritative != rhs.authoritative {return false}
    if lhs._label != rhs._label {return false}
    if lhs.size != rhs.size {return false}
    if lhs.presences != rhs.presences {return false}
    if lhs._self_p != rhs._self_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchCreate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchCreate, rhs: Nakama_Realtime_MatchCreate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "presence"),
    3: .standard(proto: "op_code"),
    4: .same(proto: "data"),
    5: .same(proto: "reliable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.matchID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._presence) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.opCode) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.reliable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    if let v = self._presence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.opCode != 0 {
      try visitor.visitSingularInt64Field(value: self.opCode, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if self.reliable != false {
      try visitor.visitSingularBoolField(value: self.reliable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchData, rhs: Nakama_Realtime_MatchData) -> Bool {
    if lhs.matchID != rhs.matchID {return false}
    if lhs._presence != rhs._presence {return false}
    if lhs.opCode != rhs.opCode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.reliable != rhs.reliable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchDataSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchDataSend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .standard(proto: "op_code"),
    3: .same(proto: "data"),
    4: .same(proto: "presences"),
    5: .same(proto: "reliable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.matchID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.opCode) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.presences) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.reliable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    if self.opCode != 0 {
      try visitor.visitSingularInt64Field(value: self.opCode, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if !self.presences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.presences, fieldNumber: 4)
    }
    if self.reliable != false {
      try visitor.visitSingularBoolField(value: self.reliable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchDataSend, rhs: Nakama_Realtime_MatchDataSend) -> Bool {
    if lhs.matchID != rhs.matchID {return false}
    if lhs.opCode != rhs.opCode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.presences != rhs.presences {return false}
    if lhs.reliable != rhs.reliable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchJoin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "token"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .matchID(v)}
      }()
      case 2: try {
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .token(v)}
      }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.id {
    case .matchID?: try {
      guard case .matchID(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .token?: try {
      guard case .token(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchJoin, rhs: Nakama_Realtime_MatchJoin) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchLeave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchLeave"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.matchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchLeave, rhs: Nakama_Realtime_MatchLeave) -> Bool {
    if lhs.matchID != rhs.matchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchPresenceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchPresenceEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "joins"),
    3: .same(proto: "leaves"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.matchID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.joins) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.leaves) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    if !self.joins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.joins, fieldNumber: 2)
    }
    if !self.leaves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaves, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchPresenceEvent, rhs: Nakama_Realtime_MatchPresenceEvent) -> Bool {
    if lhs.matchID != rhs.matchID {return false}
    if lhs.joins != rhs.joins {return false}
    if lhs.leaves != rhs.leaves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchmakerAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchmakerAdd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_count"),
    2: .standard(proto: "max_count"),
    3: .same(proto: "query"),
    4: .standard(proto: "string_properties"),
    5: .standard(proto: "numeric_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxCount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.stringProperties) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.numericProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minCount != 0 {
      try visitor.visitSingularInt32Field(value: self.minCount, fieldNumber: 1)
    }
    if self.maxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCount, fieldNumber: 2)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 3)
    }
    if !self.stringProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.stringProperties, fieldNumber: 4)
    }
    if !self.numericProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.numericProperties, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchmakerAdd, rhs: Nakama_Realtime_MatchmakerAdd) -> Bool {
    if lhs.minCount != rhs.minCount {return false}
    if lhs.maxCount != rhs.maxCount {return false}
    if lhs.query != rhs.query {return false}
    if lhs.stringProperties != rhs.stringProperties {return false}
    if lhs.numericProperties != rhs.numericProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchmakerMatched: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchmakerMatched"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
    2: .standard(proto: "match_id"),
    3: .same(proto: "token"),
    4: .same(proto: "users"),
    5: .same(proto: "self"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ticket) }()
      case 2: try {
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .matchID(v)}
      }()
      case 3: try {
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .token(v)}
      }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._self_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticket.isEmpty {
      try visitor.visitSingularStringField(value: self.ticket, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.id {
    case .matchID?: try {
      guard case .matchID(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .token?: try {
      guard case .token(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 4)
    }
    if let v = self._self_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchmakerMatched, rhs: Nakama_Realtime_MatchmakerMatched) -> Bool {
    if lhs.ticket != rhs.ticket {return false}
    if lhs.id != rhs.id {return false}
    if lhs.users != rhs.users {return false}
    if lhs._self_p != rhs._self_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchmakerMatched.MatchmakerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Nakama_Realtime_MatchmakerMatched.protoMessageName + ".MatchmakerUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presence"),
    5: .standard(proto: "string_properties"),
    6: .standard(proto: "numeric_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presence) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.stringProperties) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.numericProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._presence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.stringProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.stringProperties, fieldNumber: 5)
    }
    if !self.numericProperties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.numericProperties, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchmakerMatched.MatchmakerUser, rhs: Nakama_Realtime_MatchmakerMatched.MatchmakerUser) -> Bool {
    if lhs._presence != rhs._presence {return false}
    if lhs.stringProperties != rhs.stringProperties {return false}
    if lhs.numericProperties != rhs.numericProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchmakerRemove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchmakerRemove"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ticket) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticket.isEmpty {
      try visitor.visitSingularStringField(value: self.ticket, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchmakerRemove, rhs: Nakama_Realtime_MatchmakerRemove) -> Bool {
    if lhs.ticket != rhs.ticket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_MatchmakerTicket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchmakerTicket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ticket) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticket.isEmpty {
      try visitor.visitSingularStringField(value: self.ticket, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_MatchmakerTicket, rhs: Nakama_Realtime_MatchmakerTicket) -> Bool {
    if lhs.ticket != rhs.ticket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Notifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notifications"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notifications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Notifications, rhs: Nakama_Realtime_Notifications) -> Bool {
    if lhs.notifications != rhs.notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Ping, rhs: Nakama_Realtime_Ping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Pong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pong"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Pong, rhs: Nakama_Realtime_Pong) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.presences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.presences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.presences, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Status, rhs: Nakama_Realtime_Status) -> Bool {
    if lhs.presences != rhs.presences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_StatusFollow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusFollow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_ids"),
    2: .same(proto: "usernames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.usernames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_StatusFollow, rhs: Nakama_Realtime_StatusFollow) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_StatusPresenceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusPresenceEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "joins"),
    3: .same(proto: "leaves"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.joins) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.leaves) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.joins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.joins, fieldNumber: 2)
    }
    if !self.leaves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaves, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_StatusPresenceEvent, rhs: Nakama_Realtime_StatusPresenceEvent) -> Bool {
    if lhs.joins != rhs.joins {return false}
    if lhs.leaves != rhs.leaves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_StatusUnfollow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusUnfollow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_StatusUnfollow, rhs: Nakama_Realtime_StatusUnfollow) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_StatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_StatusUpdate, rhs: Nakama_Realtime_StatusUpdate) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_Stream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Stream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "subject"),
    3: .same(proto: "subcontext"),
    4: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subcontext) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != 0 {
      try visitor.visitSingularInt32Field(value: self.mode, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.subcontext.isEmpty {
      try visitor.visitSingularStringField(value: self.subcontext, fieldNumber: 3)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_Stream, rhs: Nakama_Realtime_Stream) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.subcontext != rhs.subcontext {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_StreamData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .same(proto: "sender"),
    3: .same(proto: "data"),
    4: .same(proto: "reliable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stream) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reliable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 3)
    }
    if self.reliable != false {
      try visitor.visitSingularBoolField(value: self.reliable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_StreamData, rhs: Nakama_Realtime_StreamData) -> Bool {
    if lhs._stream != rhs._stream {return false}
    if lhs._sender != rhs._sender {return false}
    if lhs.data != rhs.data {return false}
    if lhs.reliable != rhs.reliable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_StreamPresenceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamPresenceEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .same(proto: "joins"),
    3: .same(proto: "leaves"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stream) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.joins) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.leaves) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.joins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.joins, fieldNumber: 2)
    }
    if !self.leaves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaves, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_StreamPresenceEvent, rhs: Nakama_Realtime_StreamPresenceEvent) -> Bool {
    if lhs._stream != rhs._stream {return false}
    if lhs.joins != rhs.joins {return false}
    if lhs.leaves != rhs.leaves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Realtime_UserPresence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPresence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "username"),
    4: .same(proto: "persistence"),
    5: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.persistence) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if self.persistence != false {
      try visitor.visitSingularBoolField(value: self.persistence, fieldNumber: 4)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Realtime_UserPresence, rhs: Nakama_Realtime_UserPresence) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.persistence != rhs.persistence {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
